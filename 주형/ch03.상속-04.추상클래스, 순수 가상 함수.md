##  추상클래스, 순수 가상 함수
### 추상클래스는 한가지 이상의 순수 가상함수가 있는 클래스를 추상 클래스 이며 객체로 만들 수 없다.
#### 순수 가상함수
```
#include <iostream>

using namespace std;

class Shaped
{
public:
    double getArea() const
};
int main()
{

}
```
#### 위의 Shaped는 어떤 도형인지 알 수 없다 -> Shaped만 가지고는 getArea를 사용할 수 없다
#### 이 Shaped를 상속한 클래스를 getArea를 오버라이딩 해서 사용할 수 있다.
#### 앞에 virtual을 붙이고 =0을 붙이면 순수 가상함수가 된다
```
#include <iostream>

using namespace std;

class Shaped
{
public:
    virtual double getArea() const = 0;
    virtual ~Shaped() {} // 메모레 누수 방지
};
int main()
{
    Shaped s; // 추상클래스는 인스턴스화 할 수 없다.
}

```
#### 인스턴스화 할 수는 없지만 다른 클래스를 가리키는 포인터나 참조로는 쓸 수 있다.
#### 추상클래스를 상속받은 객체는 순수 가상함수를 overriding해주지 않으면 추상클래스가 된다
```
#include <iostream>

using namespace std;

class Shaped
{
public:
    virtual double getArea() const = 0;
    virtual ~Shaped() {}
};

class Circle : public Shaped
{
private:
    double _radious;
public:
    Circle(double radius)
        :_radious(radius)
    {

    }
};
int main()
{
    Shaped s;
    Circle c;
}
```
#### 접근이 불가능하게 할 수도 있음 private으로 선언하면 가능
#### 메모리 자체에는 있음 
```
#include <iostream>

using namespace std;

class Base {
private:
	int num;
public:
	void func()
	{
		cout << num << endl;
	}
};

class Derived : public Base
{
public:
	void foo()
	{
		func();
		this->func();
		func();
	}
};

int main() 
{
	Derived d;
	//d.num = 10; // 불가능
	d.foo();
	
}
```
#### num을 외부한테 공개를 안하지만 자식한테는 공개 하고 싶다면 protected를 사용해 주면 됨 (멤버함수도 가능)
```
#include <iostream>

using namespace std;

class Base {
protected:
	int num;
public:
	void func()
	{
		cout << num << endl;
	}
};

class Derived : public Base
{
public:
	void foo()
	{
		num += 20; // 가능
		func();
	}
};

int main() 
{
	Derived d;
	d.num = 10; // 불가능
	d.foo();
	
}
```

```
#include <iostream>

using namespace std;

class A
{

};

class B0 : public A
{
};

class B1 : public A
{

};

class C0 : public B0
{

};

class C1 : public B0
{

};

class C2 : public B1
{

};
class C3 : public B1
{

};
//            A
//        B0      B1
//     C0    c1  c2  c3
int main() 
{
	C0 c;
	C1 c3;
}
```

#### 상속은 부모객체가 먼저 생성 된다.
```
#include <iostream>

using namespace std;

class Base 
{
public:
	Base()
	{
		cout << "Base" << endl;
	}
};

class Derived :public Base
{
public:
	Derived()
	{
		cout << "Derived" << endl;
	}
};

int main() 
{
	Derived d;
}
```
#### 자식 클래스에서 부모생성자를 지정하지 않으면 parameter가 없는 default 생성자가 호출이 된다.
```
#include <iostream>

using namespace std;

class Base 
{
private:
	int num;
public:
	Base()
		:num(0)
	{
		cout << "Base" << endl;
	}
	Base(int num) : num(num)
	{
		cout << "Base(" << num << ")" << endl;
	}
};

class Derived :public Base
{
public:
	Derived()
	{
		cout << "Derived" << endl;
	}
};

int main() 
{
	Derived d;
}
```
#### 특정 생성자를 지정하고 싶다면 멤버초기화 리스트에 값을 넣어주면 된다
```
#include <iostream>

using namespace std;

class Base 
{
private:
	int num;
public:
	Base()
		:num(0)
	{
		cout << "Base" << endl;
	}
	Base(int num) : num(num)
	{
		cout << "Base(" << num << ")" << endl;
	}
	void print()
	{
		cout << num << endl;
	}
};

class Derived :public Base
{
public:
	Derived() : Base(20)
	{
		cout << "Derived" << endl;
	}
};

int main() 
{
	Derived d;
	d.print();
}
```
#### 부모클래스에서 선언된 멤버변수를 자식클래스에서 초기화는 가능하지만 가능하다면 하지 말자 -> 부모클래스에 위임하도록
```
class Derived :public Base
{
public:
	Derived(int num) : Base(num)
	{
		cout << "Derived" << endl;
	}
};
```
#### 아래 소스는 빌드가 안된다 자식클래스에서 사용할 부모클래스 생성자를 지정해 두지 않으면 default생성자를 호출하는데 int를 parameter로 받는 생성자는 만들었는데 
#### default 생성자는 만들지 않았기 때문 
```
#include <iostream>

using namespace std;

class Base 
{
private:
	int num;
public:

	Base(int num) : num(num)
	{
		cout << "Base(" << num << ")" << endl;
	}
	void print()
	{
		cout << num << endl;
	}
};

class Derived :public Base
{
public:
	Derived(int num) : Base(num)
	{
		cout << "Derived" << endl;
	}
};

int main() 
{
	Derived d;
	d.print();
}
```
#### 소멸 될땐 자식 클래스 먼저 소멸 된다.
```
#include <iostream>

using namespace std;

class Base 
{
private:
	int num;
public:
	~Base()
	{
		cout << "~Base" << endl;
	}
};

class Derived :public Base
{
public:
	~Derived()
	{
		cout << "~Derived" << endl;
	}
};

int main() 
{
	Derived d;
}
```
#### 소멸자 사용시 주의할 점이 있는데 부모로써 누군가가 쓰여야 할 예정이라면 소멸자에 virtual을 붙여야 한다??
#### 상속 관계를 나타낸다면 포인터나 참조를 이용해서 부모의 포인터 타입이 자식의 실제 객체를 가리킬 수 있다.
#### 부모가 자식을 가리키게 된다면 -> 자식은 부모의 모든 것을 상속받기 때문에 자식이 가지고 있는거 부모가 가지고 있다. -> 부모의 타입으로 가리킬 수 있다.
```
#include <iostream>

using namespace std;

class Base 
{
private:
	int num;
public:
	~Base()
	{
		cout << "~Base" << endl;
	}
	void func0()
	{

	}
};

class Derived :public Base
{
public:
	~Derived()
	{
		cout << "~Derived" << endl;
	}
	void func1()
	{

	}
};

int main() 
{
	Base* b = new Derived;
	b->func0(); // 자식은 부모의 모든 것을 같기 때문에 func0이 가능함 

	Derived* d = new Base;
	d->func1(); // 부모는 func1이 없다
}
```

#### 소멸자에 virtual를 붙여야 하는 이유는 
```
#include <iostream>

using namespace std;

class Base 
{
private:
	int num;
public:
	~Base()
	{
		cout << "~Base" << endl;
	}
};

class Derived :public Base
{
public:
	~Derived()
	{
		cout << "~Derived" << endl;
	}

};

int main() 
{
	Base* b = new Derived;
	delete b;
}
```

#### 실행시 Base 소멸자만 실행 된다.
#### 소멸자에 virtual을 붙이면 둘다 실행 된다.
```
#include <iostream>

using namespace std;

class Base 
{
private:
	int num;
public:
	virtual ~Base()
	{
		cout << "~Base" << endl;
	}
};

class Derived :public Base
{
public:
	~Derived()
	{
		cout << "~Derived" << endl;
	}

};

int main() 
{
	Base* b = new Derived;
	delete b;
}
```

#### 삭제되는 시점에서 부모의 타입임 하지만 실제로 가리키는건 자식이기 때문 
#### 부모타입에서 자식을 가리키게 되는 경우는 
```
void func(Base& b)
{

}
int main() 
{
	Derived d;
	func(d);
}
```
#### 이것이 가능해 진다. d가 func에 넘어갈 수있다 -> 부모가 가진 모든 인터페이스는 자식이 사용할 수 있기 때문 
