##  호출 연산자 오버로딩
### 함수 호출할 때 사용되는 ()연산자 
```
#include <iostream>
#include <algorithm>
using namespace std;

class Max
{
public:
	int operator()(int x, int y) const
	{
		return max(x, y);
	}
};

int main() 
{
	Max mx;
	cout << mx(1, 2) << endl;
	cout << mx(3, 2) << endl;
	cout << mx(6, 2) << endl;
	cout << mx(12, 8) << endl;
}
```
#### 일반 적인 함수와는 다르게 상태를 저장할 수 있음 
```
	cout << v << endl;;
```
#### 이것은 불가능 함
```
  operator<<(cout, v) << endl;
```
#### 인 셈인데 operator<<(cout, v)의 반환형이 없기 때문
#### 반환형을 ostream&을 반환해 줘야 함 
```
#include <iostream>

using namespace std;

class Vector
{
private:
	int x;
	int y;
	int z;
public:
	Vector(int x, int y, int z)
		:x(x), y(y), z(z)
	{

	}
	friend ostream& operator<<(ostream& os, Vector& v)
	{
		os << v.x << " " << v.y << " " << v.z << "";
		return os;
	}

};

int main()
{
	Vector v{ 1,2,3 };
	cout << v << endl;;
}
```
#### 이 소스는 동적하지 않음
```
Vector v{ 1,2,3 };
cout << v << endl;;
operator<<(cout, v); 
```
#### 위의 소스도 가능

#### cin 연산자 >> 오버로딩
```
#include <iostream>
#include <string>

using namespace std;

class Vector
{
private:
	int x;
	int y;
	int z;
public:
	Vector(){}
	Vector(int x, int y, int z)
		:x(x), y(y), z(z)
	{

	}
	friend ostream& operator<<(ostream& os, Vector& v)
	{
		os << v.x << " " << v.y << " " << v.z << "";
		return os;
	}

	friend istream& operator>>(istream& is, Vector& v)
	{
		string temp;
		is >> temp;
		v.x = stoi(temp);

		is >> temp;
		v.y = stoi(temp);

		is >> temp;
		v.z = stoi(temp);

		return is;
	}
};


int main()
{
	Vector v;
	cin >> v;
	cout << v << endl;
}
```
#### 그 외 오버로딩
```
#include <iostream>
#include <string>

using namespace std;

class Vector
{
private:
	int x;
	int y;
	int z;
public:
	Vector(){}
	Vector(int x, int y, int z)
		:x(x), y(y), z(z)
	{

	}
	friend ostream& operator<<(ostream& os, const Vector& v)
	{
		os << v.x << " " << v.y << " " << v.z << "";
		return os;
	}

	friend istream& operator>>(istream& is, Vector& v)
	{
		string temp;
		is >> temp;
		v.x = stoi(temp);

		is >> temp;
		v.y = stoi(temp);

		is >> temp;
		v.z = stoi(temp);

		return is;
	}
	Vector operator~() const
	{
		return Vector(~x, ~y, ~z);
	}
	Vector operator&(const Vector& v) const
	{
		return Vector(x & v.x, y & v.y, z & v.z);
	}
	Vector operator|(const Vector& v) const
	{
		return Vector(x | v.x, y | v.y, z | v.z);
	} 
	Vector operator^(const Vector& v) const
	{
		return Vector(x ^ v.x, y ^ v.y, z ^ v.z);
	}
	Vector operator<<(int v) const
	{
		return Vector(x << v, y << v, z << v);
	}
	Vector operator>>(int v) const
	{
		return Vector(x >> v, y >> v, z >> v);
	}
};


int main()
{
	const Vector v0{0,0,0};
	Vector v1{ 1,1,3 };
	cout << ~v0 << endl;
	cout << (v0 & v1) << endl;
	cout << (v0 | v1) << endl;
}

```
